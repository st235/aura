{
	"items": [
		{
			"id": 0,
			"title": "Bubble sort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 1,
			"title": "Odd–even sort",
			"subtitle": "Comparison sort",
			"description": "On parallel processors, with one value per processor and only local left–right neighbor connections, the processors all concurrently do a compare–exchange operation with their neighbors, alternating between odd–even and even–odd pairings. This algorithm was originally presented, and shown to be efficient on such processors, by Habermann in 1972. The algorithm extends efficiently to the case of multiple items per processor. In the Baudet–Stevenson odd–even merge-splitting algorithm, each processor sorts its own sublist at each step, using any efficient sort algorithm, and then performs a merge splitting, or transposition–merge, operation with its neighbor, with neighbor pairing alternating between odd–even and even–odd on each step.",
			"code": {
				"data": "function oddEvenSort(list) {\r\n  function swap( list, i, j ){\r\n    var temp = list[i];\r\n    list[i] = list[j];\r\n    list[j] = temp;\r\n  }\r\n\r\n  var sorted = false;\r\n  while(!sorted)\r\n  {\r\n    sorted = true;\r\n    for(var i = 1; i < list.length-1; i += 2)\r\n    {\r\n      if(list[i] > list[i+1])\r\n      {\r\n        swap(list, i, i+1);\r\n        sorted = false;\r\n      }\r\n    }\r\n\r\n    for(var i = 0; i < list.length-1; i += 2)\r\n    {\r\n      if(list[i] > list[i+1])\r\n      {\r\n        swap(list, i, i+1);\r\n        sorted = false;\r\n      }\r\n    }\r\n  }\r\n}",
				"language": "JavaScript"
			}
		},
		{
			"id": 2,
			"title": "Quicksort",
			"subtitle": "Comparison sort",
			"description": "Like Merge Sort, QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.\r\n\r\nAlways pick first element as pivot.\r\nAlways pick last element as pivot (implemented below)\r\nPick a random element as pivot.\r\nPick median as pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.",
			"code": {
				"data": "\r\n\/\/ Java program for implementation of QuickSort \r\nclass QuickSort \r\n{ \r\n    \/* This function takes last element as pivot, \r\n       places the pivot element at its correct \r\n       position in sorted array, and places all \r\n       smaller (smaller than pivot) to left of \r\n       pivot and all greater elements to right \r\n       of pivot *\/\r\n    int partition(int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high];  \r\n        int i = (low-1); \/\/ index of smaller element \r\n        for (int j=low; j<high; j++) \r\n        { \r\n            \/\/ If current element is smaller than or \r\n            \/\/ equal to pivot \r\n            if (arr[j] <= pivot) \r\n            { \r\n                i++; \r\n  \r\n                \/\/ swap arr[i] and arr[j] \r\n                int temp = arr[i]; \r\n                arr[i] = arr[j]; \r\n                arr[j] = temp; \r\n            } \r\n        } \r\n  \r\n        \/\/ swap arr[i+1] and arr[high] (or pivot) \r\n        int temp = arr[i+1]; \r\n        arr[i+1] = arr[high]; \r\n        arr[high] = temp; \r\n  \r\n        return i+1; \r\n    } \r\n  \r\n  \r\n    \/* The main function that implements QuickSort() \r\n      arr[] --> Array to be sorted, \r\n      low  --> Starting index, \r\n      high  --> Ending index *\/\r\n    void sort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            \/* pi is partitioning index, arr[pi] is  \r\n              now at right place *\/\r\n            int pi = partition(arr, low, high); \r\n  \r\n            \/\/ Recursively sort elements before \r\n            \/\/ partition and after partition \r\n            sort(arr, low, pi-1); \r\n            sort(arr, pi+1, high); \r\n        } \r\n    } \r\n  \r\n    \/* A utility function to print array of size n *\/\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    \/\/ Driver program \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = {10, 7, 8, 9, 1, 5}; \r\n        int n = arr.length; \r\n  \r\n        QuickSort ob = new QuickSort(); \r\n        ob.sort(arr, 0, n-1); \r\n  \r\n        System.out.println(\"sorted array\"); \r\n        printArray(arr); \r\n    } \r\n} ",
				"language": "Java"
			}
		},
		{
			"id": 3,
			"title": "Heapsort",
			"subtitle": "Comparison sort",
			"description": "Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.\r\n\r\nWhat is Binary Heap?\r\nLet us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source Wikipedia)\r\n\r\nA Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called as max heap and the latter is called min heap. The heap can be represented by binary tree or array.\r\n\r\n\r\n\r\nWhy array based representation for Binary Heap?\r\nSince a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2 (assuming the indexing starts at 0).\r\n\r\nHeap Sort Algorithm for sorting in increasing order:\r\n1. Build a max heap from the input data.\r\n2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.\r\n3. Repeat above steps while size of heap is greater than 1.\r\n\r\nHow to build the heap?\r\nHeapify procedure can be applied to a node only if its children nodes are heapified. So the heapification must be performed in the bottom up order.",
			"code": {
				"data": "public class HeapSort \r\n{ \r\n    public void sort(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n  \r\n        \/\/ Build heap (rearrange array) \r\n        for (int i = n \/ 2 - 1; i >= 0; i--) \r\n            heapify(arr, n, i); \r\n  \r\n        \/\/ One by one extract an element from heap \r\n        for (int i=n-1; i>=0; i--) \r\n        { \r\n            \/\/ Move current root to end \r\n            int temp = arr[0]; \r\n            arr[0] = arr[i]; \r\n            arr[i] = temp; \r\n  \r\n            \/\/ call max heapify on the reduced heap \r\n            heapify(arr, i, 0); \r\n        } \r\n    } \r\n  \r\n    \/\/ To heapify a subtree rooted with node i which is \r\n    \/\/ an index in arr[]. n is size of heap \r\n    void heapify(int arr[], int n, int i) \r\n    { \r\n        int largest = i; \/\/ Initialize largest as root \r\n        int l = 2*i + 1; \/\/ left = 2*i + 1 \r\n        int r = 2*i + 2; \/\/ right = 2*i + 2 \r\n  \r\n        \/\/ If left child is larger than root \r\n        if (l < n && arr[l] > arr[largest]) \r\n            largest = l; \r\n  \r\n        \/\/ If right child is larger than largest so far \r\n        if (r < n && arr[r] > arr[largest]) \r\n            largest = r; \r\n  \r\n        \/\/ If largest is not root \r\n        if (largest != i) \r\n        { \r\n            int swap = arr[i]; \r\n            arr[i] = arr[largest]; \r\n            arr[largest] = swap; \r\n  \r\n            \/\/ Recursively heapify the affected sub-tree \r\n            heapify(arr, n, largest); \r\n        } \r\n    } \r\n  \r\n    \/* A utility function to print array of size n *\/\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    \/\/ Driver program \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = {12, 11, 13, 5, 6, 7}; \r\n        int n = arr.length; \r\n  \r\n        HeapSort ob = new HeapSort(); \r\n        ob.sort(arr); \r\n  \r\n        System.out.println(\"Sorted array is\"); \r\n        printArray(arr); \r\n    } \r\n}",
				"language": "Java"
			}
		},
		{
			"id": 4,
			"title": "Shellsort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 5,
			"title": "Merge sort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 6,
			"title": "Introsort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 7,
			"title": "nsertion sort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 8,
			"title": "Selection sort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		},
		{
			"id": 9,
			"title": "Cocktail shaker sort",
			"subtitle": "Comparison sort",
			"description": "Bubble sort algorithm starts by comparing the first two elements of an array and swapping if necessary, i.e., if you want to sort the elements of array in ascending order and if the first element is greater than second then, you need to swap the elements but, if the first element is smaller than second, you mustn't swap the element. Then, again second and third elements are compared and swapped if it is necessary and this process go on until last and second last element is compared and swapped. This completes the first step of bubble sort. If there are n elements to be sorted then, the process mentioned above should be repeated n-1 times to get required result. But, for better performance, in second step, last and second last elements are not compared becuase, the proper element is automatically placed at last after first step. Similarly, in third step, last and second last and second last and third last elements are not compared and so on. A figure is worth a thousand words so, acknowledge this figure for better understanding of bubble sort.",
			"code": {
				"data": "import java.util.Scanner;\r\n \r\nclass BubbleSort {\r\n  public static void main(String []args) {\r\n    int n, c, d, swap;\r\n    Scanner in = new Scanner(System.in);\r\n \r\n    System.out.println(\"Input number of integers to sort\");\r\n    n = in.nextInt();\r\n \r\n    int array[] = new int[n];\r\n \r\n    System.out.println(\"Enter \" + n + \" integers\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      array[c] = in.nextInt();\r\n   \r\n    for (c = 0; c < ( n - 1 ); c++) {\r\n      for (d = 0; d < n - c - 1; d++) {\r\n        if (array[d] > array[d+1]) \/* For descending order use < *\/\r\n        {\r\n          swap       = array[d];\r\n          array[d]   = array[d+1];\r\n          array[d+1] = swap;\r\n        }\r\n      }\r\n    }\r\n \r\n    System.out.println(\"Sorted list of numbers:\");\r\n \r\n    for (c = 0; c < n; c++)\r\n      System.out.println(array[c]);\r\n  }\r\n}",
				"language": "Java"
			}
		}
	]
}
